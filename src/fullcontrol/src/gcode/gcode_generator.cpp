/**
 * @file gcode_generator.cpp
 * @brief G代码生成器类实现
 * @author FullControl C++ Team
 * @version 1.0.0
 */

#include "fullcontrol/gcode/gcode_generator.h"
#include <fstream>
#include <sstream>
#include <iomanip>
#include <ctime>

namespace fullcontrol {

    void GcodeControls::initialize() {
        if (initial_gcode.empty()) {
            initial_gcode = "; FullControl C++ Generated G-code\n"
                           "; Generated by FullControl C++ v1.0.0\n"
                           "G21 ; Set units to millimeters\n"
                           "G90 ; Set absolute positioning\n"
                           "M82 ; Set extruder to absolute mode\n"
                           "G28 ; Home all axes\n";
        }
        
        if (final_gcode.empty()) {
            final_gcode = "M104 S0 ; Turn off extruder\n"
                         "M140 S0 ; Turn off bed\n"
                         "G91 ; Set relative positioning\n"
                         "G1 Z10 ; Move up 10mm\n"
                         "G90 ; Set absolute positioning\n"
                         "G1 X0 Y0 ; Move to origin\n"
                         "M84 ; Disable steppers\n";
        }
    }



    std::string GcodeGenerator::generateGcode(const std::vector<std::shared_ptr<void>>& steps,
                                             const GcodeControls& controls,
                                             bool show_tips) {
        GcodeControls local_controls = controls;
        local_controls.initialize();
        
        if (show_tips) {
            // 这里可以添加提示信息
        }
        
        State state(steps, local_controls);
        
        // 添加初始G代码
        state.gcode.push_back(state.controls->initial_gcode);
        
        // 处理所有步骤
        while (state.i < state.steps.size()) {
            std::string gcode_line = processStep(state, state.steps[state.i]);
            if (!gcode_line.empty()) {
                state.gcode.push_back(gcode_line);
            }
            state.i++;
        }
        
        // 添加结束G代码
        state.gcode.push_back(state.controls->final_gcode);
        
        // 合并所有G代码行
        std::ostringstream result;
        for (const auto& line : state.gcode) {
            result << line << "\n";
        }
        
        // 保存到文件（如果指定了文件名）
        if (!state.controls->save_as.empty()) {
            std::string filename = state.controls->save_as;
            if (state.controls->include_date) {
                std::time_t now = std::time(0);
                std::tm* timeinfo = std::localtime(&now);
                char buffer[80];
                std::strftime(buffer, sizeof(buffer), "__%d-%m-%Y__%H-%M-%S", timeinfo);
                filename += buffer;
            }
            filename += ".gcode";
            saveGcode(result.str(), filename);
        }
        
        return result.str();
    }

    void GcodeGenerator::saveGcode(const std::string& gcode, const std::string& filename) {
        std::ofstream file(filename);
        if (file.is_open()) {
            file << gcode;
            file.close();
        } else {
            throw std::runtime_error("Cannot open file for writing: " + filename);
        }
    }

    std::string GcodeGenerator::processStep(State& state, const std::shared_ptr<void>& step) {
        // 这里需要根据具体的步骤类型来处理
        // 由于我们使用void*，这里需要类型转换和分发
        // 在实际实现中，应该使用更具体的类型系统
        
        // 临时实现：假设步骤是Point类型
        try {
            const Point* point = static_cast<const Point*>(step.get());
            if (point) {
                state.moveTo(*point, false); // 假设是打印移动
                return ""; // moveTo已经添加了G代码
            }
        } catch (...) {
            // 类型转换失败，忽略
        }
        
        return "";
    }

} // namespace fullcontrol
