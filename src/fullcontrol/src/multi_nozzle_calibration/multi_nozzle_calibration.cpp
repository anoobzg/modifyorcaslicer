/**
 * @file multi_nozzle_calibration.cpp
 * @brief Multi-nozzle calibration GCode generator implementation
 */

#include "fullcontrol/multi_nozzle_calibration/multi_nozzle_calibration.h"
#include <chrono>
#include <ctime>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

namespace fullcontrol {

MultiNozzleCalibration::MultiNozzleCalibration(const MultiNozzleParams& params)
    : m_params(params)
{
}

void MultiNozzleCalibration::setParams(const MultiNozzleParams& params)
{
    m_params = params;
}

double MultiNozzleCalibration::calculateDistance(const Point2D& p1, const Point2D& p2)
{
    return std::sqrt(std::pow(p2.x - p1.x, 2) + std::pow(p2.y - p1.y, 2));
}

std::vector<Quadrant> MultiNozzleCalibration::getQuadrants()
{
    double quadrant_width = m_params.bed_width / 2.0;
    double quadrant_height = m_params.bed_height / 2.0;
    
    std::vector<Quadrant> quadrants;
    quadrants.emplace_back(0, "T0", m_params.bed_min_x + quadrant_width * 0.5, 
                          m_params.bed_min_y + quadrant_height * 0.5, "Bottom-Left");
    quadrants.emplace_back(1, "T1", m_params.bed_min_x + quadrant_width * 0.5, 
                          m_params.bed_min_y + quadrant_height * 1.5, "Top-Left");
    quadrants.emplace_back(2, "T2", m_params.bed_min_x + quadrant_width * 1.5, 
                          m_params.bed_min_y + quadrant_height * 1.5, "Top-Right");
    quadrants.emplace_back(3, "T3", m_params.bed_min_x + quadrant_width * 1.5, 
                          m_params.bed_min_y + quadrant_height * 0.5, "Bottom-Right");
    
    return quadrants;
}

void MultiNozzleCalibration::generateHeader(std::ostringstream& stream, int num_layers)
{
    stream << "; HEADER_BLOCK_START\n";
    
    // Use LightMaker header format for recognition and IDEX mode support
    stream << "; generated by LightMaker2.3.0 on ";
    
    // Get current time
    auto now = std::chrono::system_clock::now();
    std::time_t now_time = std::chrono::system_clock::to_time_t(now);
    struct tm time_info;
    #ifdef _WIN32
        localtime_s(&time_info, &now_time);
    #else
        localtime_r(&now_time, &time_info);
    #endif
    stream << std::put_time(&time_info, "%Y-%m-%d at %H:%M:%S") << "\n";
    
    stream << "; Multi-Nozzle Calibration - 4 Quadrants\n";
    stream << "; total layer number: " << num_layers << "\n";
    stream << "; filament_density: 1.24,1.24,1.24,1.24\n";
    stream << "; filament_diameter: " << m_params.filament_diameter << "," 
           << m_params.filament_diameter << "," << m_params.filament_diameter << "," 
           << m_params.filament_diameter << "\n";
    
    stream << "; filament_colour = ";
    if (!m_params.filament_colors.empty()) {
        for (size_t i = 0; i < 4; ++i) {
            if (i > 0) stream << ";";
            if (i < m_params.filament_colors.size()) {
                stream << m_params.filament_colors[i];
            } else {
                const char* default_colors[] = {"#A7A9AA", "#00C1AE", "#F4E2C1", "#ED1C24"};
                stream << default_colors[i];
            }
        }
    } else {
        stream << "#A7A9AA;#00C1AE;#F4E2C1;#ED1C24";
    }
    stream << "\n";
    
    stream << "; max_z_height: " << m_params.total_height << "\n";
    
    stream << "; bed_shape = ";
    if (!m_params.bed_shape.empty()) {
        for (size_t i = 0; i < m_params.bed_shape.size(); ++i) {
            const Point2D& pt = m_params.bed_shape[i];
            if (i > 0) stream << ",";
            stream << static_cast<int>(pt.x) << "x" << static_cast<int>(pt.y);
        }
    } else {
        stream << "0x0," << static_cast<int>(m_params.bed_width) << "x0,"
               << static_cast<int>(m_params.bed_width) << "x" << static_cast<int>(m_params.bed_height)
               << ",0x" << static_cast<int>(m_params.bed_height);
    }
    stream << "\n";
    
    stream << "; bed_size: " << m_params.bed_width << " x " << m_params.bed_height << " mm\n";
    stream << "; HEADER_BLOCK_END\n\n";
    
    double quadrant_width = m_params.bed_width / 2.0;
    double quadrant_height = m_params.bed_height / 2.0;
    stream << "; === Multi-Nozzle Calibration Configuration ===\n";
    stream << "; Bed divided into 4 quadrants (2x2 layout)\n";
    stream << "; Each quadrant: " << quadrant_width << " x " << quadrant_height << " mm\n";
    stream << "; Rectangle 1 size: " << m_params.rect_length << " x " << m_params.rect_width << " mm\n";
    stream << "; Rectangle 2 size: " << m_params.rect_width << " x " << m_params.rect_length << " mm (rotated 90°)\n";
    stream << "; Each quadrant has 2 rectangles\n";
    stream << "; T0: Bottom-Left, T1: Top-Left, T2: Top-Right, T3: Bottom-Right\n";
    stream << "; nozzle_diameter: " << m_params.nozzle_diameter << " mm\n";
    stream << "; layer_height: " << m_params.layer_height << " mm\n";
    stream << "; extrusion_width: " << (m_params.nozzle_diameter * 1.2) << " mm\n";
    stream << "; print_speed: " << m_params.print_speed << " mm/s\n";
    stream << ";\n\n";
    
    int estimated_time = num_layers * 8;
    stream << "M73 P0 R" << estimated_time << "\n";
    stream << ";TYPE:Custom\n";
    stream << "PRINT_START  TOOL_TEMP=" << m_params.nozzle_temp << " BED_TEMP=" << m_params.bed_temp << " TOOL=0\n\n";
    stream << "M83 ; use relative distances for extrusion\n";
    
    stream << "G92 X0 Y0 Z0 E0 ; set current position as origin\n";
    stream << "G0 Z" << m_params.z_hop << " F600 ; lift Z to " << m_params.z_hop << "mm\n";
    stream << "G0 F3000 X0 Y0 ; move to origin\n\n";
}

void MultiNozzleCalibration::generateFooter(std::ostringstream& stream)
{
    stream << "\n;TYPE:Custom\n";
    stream << "; filament end gcode\n";
    stream << "; filament end gcode\n";
    stream << "; filament end gcode\n";
    stream << "; filament end gcode\n";
    stream << "END_PRINT\n";
    stream << "M73 P100 R0\n\n";
    
    stream << "; CONFIG_BLOCK_START\n";
    
    stream << "; idex_mode = Pack\n";
    stream << "; hot_bed_divide = Four_Areas\n";
    
    // Basic print parameters
    stream << "; nozzle_diameter = " << m_params.nozzle_diameter << "\n";
    stream << "; layer_height = " << m_params.layer_height << "\n";
    stream << "; initial_layer_print_height = " << m_params.layer_height << "\n";
    stream << "; line_width = " << (m_params.nozzle_diameter * 1.2) << "\n";
    stream << "; outer_wall_line_width = " << (m_params.nozzle_diameter * 1.2) << "\n";
    stream << "; inner_wall_line_width = " << (m_params.nozzle_diameter * 1.2) << "\n";
    stream << "; sparse_infill_line_width = " << (m_params.nozzle_diameter * 1.2) << "\n";
    stream << "; top_surface_line_width = " << (m_params.nozzle_diameter * 1.2) << "\n";
    
    // Temperature parameters
    stream << "; nozzle_temperature = " << m_params.nozzle_temp << "\n";
    stream << "; nozzle_temperature_initial_layer = " << m_params.nozzle_temp << "\n";
    stream << "; bed_temperature = " << m_params.bed_temp << "\n";
    stream << "; bed_temperature_initial_layer_single = " << m_params.bed_temp << "\n";
    
    stream << "; filament_diameter = " << m_params.filament_diameter << "\n";
    stream << "; filament_density = 1.24\n";
    stream << "; filament_cost = 20\n";
    
    stream << "; retraction_length = " << m_params.retract_length << "\n";
    stream << "; retraction_speed = " << m_params.retract_speed << "\n";
    stream << "; deretraction_speed = " << m_params.retract_speed << "\n";
    stream << "; retract_lift_above = " << m_params.z_hop << "\n";
    stream << "; retract_lift_below = 0\n";
    stream << "; retract_restart_extra = 0\n";
    
    stream << "; outer_wall_speed = " << m_params.print_speed << "\n";
    stream << "; inner_wall_speed = " << m_params.print_speed << "\n";
    stream << "; sparse_infill_speed = " << m_params.print_speed << "\n";
    stream << "; internal_solid_infill_speed = " << m_params.print_speed << "\n";
    stream << "; top_surface_speed = " << m_params.print_speed << "\n";
    stream << "; travel_speed = " << (m_params.print_speed * 2) << "\n";
    stream << "; initial_layer_speed = " << (m_params.print_speed * 0.5) << "\n";
    
    stream << "; default_acceleration = 1000\n";
    stream << "; outer_wall_acceleration = 1000\n";
    stream << "; inner_wall_acceleration = 1000\n";
    stream << "; top_surface_acceleration = 1000\n";
    stream << "; travel_acceleration = 1000\n";
    
    stream << "; default_jerk = 8\n";
    stream << "; outer_wall_jerk = 8\n";
    stream << "; inner_wall_jerk = 8\n";
    stream << "; top_surface_jerk = 8\n";
    stream << "; travel_jerk = 8\n";
    
    stream << "; enable_overhang_speed = 1\n";
    stream << "; slow_down_min_speed = 10\n";
    stream << "; overhang_1_4_speed = 0\n";
    stream << "; overhang_2_4_speed = 20\n";
    stream << "; overhang_3_4_speed = 10\n";
    stream << "; overhang_4_4_speed = 5\n";
    
    stream << "; close_fan_the_first_x_layers = 1\n";
    stream << "; full_fan_speed_layer = 0\n";
    stream << "; fan_max_speed = 100\n";
    stream << "; fan_min_speed = 20\n";
    stream << "; slow_down_layer_time = 8\n";
    
    stream << "; sparse_infill_density = 15%\n";
    stream << "; sparse_infill_pattern = grid\n";
    stream << "; wall_loops = 2\n";
    stream << "; top_shell_layers = 3\n";
    stream << "; bottom_shell_layers = 3\n";
    stream << "; wall_generator = classic\n";
    
    stream << "; skirt_loops = 1\n";
    stream << "; skirt_distance = 2\n";
    stream << "; skirt_height = 1\n";
    stream << "; brim_width = 0\n";
    stream << "; brim_type = no_brim\n";
    
    // Other required parameters
    stream << "; enable_arc_fitting = 0\n";
    stream << "; gcode_flavor = marlin\n";
    stream << "; single_extruder_multi_material = 0\n";
    stream << "; spiral_mode = 0\n";
    stream << "; enable_prime_tower = 0\n";
    stream << "; printable_area = 0x0,330x0,330x330,0x330\n";
    stream << "; printable_height = 330\n";
    stream << "; extruder_clearance_radius = 35\n";
    stream << "; extruder_clearance_height_to_rod = 34\n";
    stream << "; extruder_clearance_height_to_lid = 120\n";
    
    stream << "; enable_support = 0\n";
    stream << "; support_type = normal\n";
    stream << "; support_threshold_angle = 30\n";
    stream << "; support_on_build_plate_only = 0\n";
    stream << "; support_interface_spacing = 0.2\n";
    stream << "; support_interface_loop_pattern = 0\n";
    stream << "; support_base_pattern = default\n";
    stream << "; support_base_pattern_spacing = 2.5\n";
    stream << "; support_speed = 80\n";
    stream << "; support_interface_speed = 80\n";
    
    stream << "; seam_position = aligned\n";
    stream << "; seam_gap = 0\n";
    stream << "; role_based_wipe_speed = 0\n";
    stream << "; wipe_speed = 80%\n";
    
    stream << "; bridge_flow = 1\n";
    stream << "; bridge_speed = 25\n";
    stream << "; internal_bridge_speed = 150\n";
    stream << "; bridge_angle = 0\n";
    
    stream << "; solid_infill_filament = 1\n";
    stream << "; infill_direction = 45\n";
    stream << "; minimum_sparse_infill_area = 15\n";
    stream << "; reduce_infill_retraction = 1\n";
    stream << "; infill_anchor = 600%\n";
    stream << "; infill_anchor_max = 50\n";
    
    stream << "; extrusion_multiplier = 1\n";
    stream << "; initial_layer_flow_ratio = 1\n";
    stream << "; default_filament_profile = \n";
    stream << "; filament_flow_ratio = 1\n";
    stream << "; filament_max_volumetric_speed = 0\n";
    
    stream << "; detect_thin_wall = 0\n";
    stream << "; detect_overhang_wall = 1\n";
    stream << "; precise_outer_wall = 0\n";
    stream << "; overhang_reverse = 0\n";
    stream << "; fuzzy_skin = none\n";
    stream << "; fuzzy_skin_thickness = 0.3\n";
    stream << "; fuzzy_skin_point_distance = 0.8\n";
    
    stream << "; reduce_crossing_wall = 0\n";
    stream << "; max_travel_detour_distance = 0\n";
    stream << "; bottom_surface_pattern = monotonic\n";
    stream << "; top_surface_pattern = monotonicline\n";
    stream << "; ironing_type = no ironing\n";
    stream << "; ironing_flow = 10%\n";
    stream << "; ironing_spacing = 0.1\n";
    stream << "; ironing_speed = 15\n";
    
    stream << "; CONFIG_BLOCK_END\n";
}

void MultiNozzleCalibration::generateSkirt(std::ostringstream& stream,
                                           double min_x, double min_y,
                                           double max_x, double max_y,
                                           double e_per_mm,
                                           bool is_first)
{
    double extrusion_width = m_params.nozzle_diameter * 1.2;
    double print_speed_mmmin = m_params.print_speed * 60;
    
    for (int skirt_loop = 0; skirt_loop < m_params.skirt_loops; ++skirt_loop) {
        double offset = skirt_loop * extrusion_width;
        double sx1 = min_x - offset;
        double sy1 = min_y - offset;
        double sx2 = max_x + offset;
        double sy2 = max_y + offset;
        
        double skirt_w = sx2 - sx1;
        double skirt_h = sy2 - sy1;
        
        if (skirt_loop == 0 && is_first) {
            stream << "G1 F" << print_speed_mmmin;
        } else if (skirt_loop == 0) {
            stream << "G1 F" << print_speed_mmmin;
        } else {
            stream << "G1";
        }
        stream << " X" << sx2 << " Y" << sy1 << " E" << (skirt_w * e_per_mm) << "\n";
        stream << "G1 X" << sx2 << " Y" << sy2 << " E" << (skirt_h * e_per_mm) << "\n";
        stream << "G1 X" << sx1 << " Y" << sy2 << " E" << (skirt_w * e_per_mm) << "\n";
        stream << "G1 X" << sx1 << " Y" << sy1 << " E" << (skirt_h * e_per_mm) << "\n";
    }
}

void MultiNozzleCalibration::generateRectangle(std::ostringstream& stream,
                                               const std::vector<Point2D>& corners,
                                               double e_per_mm,
                                               bool is_first_segment)
{
    double print_speed_mmmin = m_params.print_speed * 60;
    
    for (size_t i = 1; i < corners.size(); ++i) {
        const Point2D& pt = corners[i];
        const Point2D& prev_pt = corners[i - 1];
        double distance = calculateDistance(prev_pt, pt);
        double e_for_segment = distance * e_per_mm;
        
        if (i == 1 && is_first_segment) {
            stream << "G1 F" << print_speed_mmmin << " X" << pt.x 
                  << " Y" << pt.y << " E" << e_for_segment << "\n";
        } else {
            stream << "G1 X" << pt.x << " Y" << pt.y 
                  << " E" << e_for_segment << "\n";
        }
    }
}

void MultiNozzleCalibration::generateQuadrantGCode(std::ostringstream& stream,
                                                   const Quadrant& quadrant,
                                                   size_t quad_idx,
                                                   int num_layers,
                                                   double e_per_mm,
                                                   bool is_last_quadrant)
{
    stream << "\n; ===============================================\n";
    stream << "; === " << quadrant.name << " Quadrant - " << quadrant.tool_name << " ===\n";
    stream << "; ===============================================\n\n";
    
    stream << quadrant.tool_name << " ; select tool\n\n";
    
    // Calculate rectangle positions in this quadrant
    double total_width = m_params.rect_length + m_params.rect_spacing + m_params.rect_width;
    double total_height_rects = std::max(m_params.rect_width, m_params.rect_spacing + m_params.rect_length);
    double quad_start_x = quadrant.center_x - total_width / 2.0;
    double quad_start_y = quadrant.center_y - total_height_rects / 2.0;
    
    double extrusion_width = m_params.nozzle_diameter * 1.2;
    double travel_speed = 3000;
    double print_speed_mmmin = m_params.print_speed * 60;
    double retract_speed = m_params.retract_speed * 60;
    
    for (int layer = 0; layer < num_layers; ++layer) {
        double current_z = (layer + 1) * m_params.layer_height;
        
        stream << "\n;LAYER_CHANGE\n";
        stream << ";Z:" << current_z << "\n";
        stream << ";HEIGHT:" << m_params.layer_height << "\n";
        stream << "; Layer " << (layer + 1) << " of " << num_layers 
              << " (" << quadrant.name << " - " << quadrant.tool_name << ")\n\n";
        
        stream << ";TYPE:Outer wall\n";
        stream << "; Rectangle 1 (original " << m_params.rect_length << "x" << m_params.rect_width << ")\n";
        
        std::vector<Point2D> rectangle1;
        rectangle1.emplace_back(quad_start_x, quad_start_y);
        rectangle1.emplace_back(quad_start_x + m_params.rect_length, quad_start_y);
        rectangle1.emplace_back(quad_start_x + m_params.rect_length, quad_start_y + m_params.rect_width);
        rectangle1.emplace_back(quad_start_x, quad_start_y + m_params.rect_width);
        rectangle1.emplace_back(quad_start_x, quad_start_y);
        
        if (layer == 0) {
            stream << ";TYPE:Skirt\n";
            stream << "; Skirt for Rectangle 1 - 3 loops\n";
            
            double skirt1_min_x = quad_start_x - m_params.skirt_distance;
            double skirt1_min_y = quad_start_y - m_params.skirt_distance;
            double skirt1_max_x = quad_start_x + m_params.rect_length + m_params.skirt_distance;
            double skirt1_max_y = quad_start_y + m_params.rect_width + m_params.skirt_distance;
            
            // Move to skirt start
            if (quad_idx == 0) {
                stream << "G0 F" << travel_speed << " X" << skirt1_min_x << " Y" << skirt1_min_y << "\n";
                stream << "G0 Z" << current_z << " F600 ; lower to print height\n";
            } else {
                stream << "G0 X" << skirt1_min_x << " Y" << skirt1_min_y << "\n";
                stream << "G0 Z" << current_z << " F600 ; lower to print height\n";
                stream << "G1 E" << m_params.retract_length << " F" << retract_speed << " ; unretract\n";
            }
            
            generateSkirt(stream, skirt1_min_x, skirt1_min_y, skirt1_max_x, skirt1_max_y, e_per_mm, true);
            stream << "\n";
        }
        
        if (layer == 0) {
            stream << "G0 X" << rectangle1[0].x << " Y" << rectangle1[0].y << "\n";
        } else {
            stream << "G0 Z" << current_z << " X" << rectangle1[0].x 
                  << " Y" << rectangle1[0].y << "\n";
        }
        
        generateRectangle(stream, rectangle1, e_per_mm, true);
        
        stream << "G1 E-" << m_params.retract_length << " F" << retract_speed << " ; retract\n";
        stream << "G0 Z" << (current_z + m_params.z_hop_within_layer) << " F600 ; lift Z by " 
              << m_params.z_hop_within_layer << "mm\n";
        
        // Rectangle 2 (rotated 90°)
        double rect2_start_x = quad_start_x + m_params.rect_length + m_params.rect_spacing;
        double rect2_start_y = quad_start_y + m_params.rect_spacing;
        
        std::vector<Point2D> rectangle2;
        rectangle2.emplace_back(rect2_start_x, rect2_start_y);
        rectangle2.emplace_back(rect2_start_x + m_params.rect_width, rect2_start_y);
        rectangle2.emplace_back(rect2_start_x + m_params.rect_width, rect2_start_y + m_params.rect_length);
        rectangle2.emplace_back(rect2_start_x, rect2_start_y + m_params.rect_length);
        rectangle2.emplace_back(rect2_start_x, rect2_start_y);
        
        if (layer == 0) {
            stream << ";TYPE:Skirt\n";
            stream << "; Skirt for Rectangle 2 - 3 loops\n";
            
            double skirt2_min_x = rect2_start_x - m_params.skirt_distance;
            double skirt2_min_y = rect2_start_y - m_params.skirt_distance;
            double skirt2_max_x = rect2_start_x + m_params.rect_width + m_params.skirt_distance;
            double skirt2_max_y = rect2_start_y + m_params.rect_length + m_params.skirt_distance;
            
            stream << "G0 X" << skirt2_min_x << " Y" << skirt2_min_y << " ; travel to rect2 skirt\n";
            stream << "G0 Z" << current_z << " F600 ; lower Z to print height\n";
            stream << "G1 E" << m_params.retract_length << " F" << retract_speed << " ; unretract\n";
            
            generateSkirt(stream, skirt2_min_x, skirt2_min_y, skirt2_max_x, skirt2_max_y, e_per_mm, false);
            
            stream << "G1 E-" << m_params.retract_length << " F" << retract_speed << " ; retract\n";
            stream << "G0 Z" << (current_z + m_params.z_hop_within_layer) << " F600 ; lift Z by " 
                  << m_params.z_hop_within_layer << "mm\n";
            stream << "\n";
        }
        
        stream << ";TYPE:Outer wall\n";
        stream << "; Rectangle 2 (rotated " << m_params.rect_width << "x" << m_params.rect_length << ")\n";
        
        stream << "G0 X" << rectangle2[0].x << " Y" << rectangle2[0].y << " ; travel\n";
        stream << "G0 Z" << current_z << " F600 ; lower Z to print height\n";
        stream << "G1 E" << m_params.retract_length << " F" << retract_speed << " ; unretract\n";
        
        generateRectangle(stream, rectangle2, e_per_mm, true);
        
        stream << "\n";
    }
    
    if (!is_last_quadrant) {
        stream << "G1 E-" << m_params.retract_length << " F" << retract_speed << " ; retract before next quadrant\n";
        stream << "G0 Z" << m_params.z_hop << " F600 ; lift Z to " << m_params.z_hop << "mm for safety\n\n";
    }
}

std::string MultiNozzleCalibration::generateGCode()
{
    std::ostringstream gcode_stream;
    
    int num_layers = static_cast<int>(m_params.total_height / m_params.layer_height);
    
    double extrusion_width = m_params.nozzle_diameter * 1.2;
    double mm3_per_mm = extrusion_width * m_params.layer_height;
    double mm_filament_per_mm3 = 4.0 / (M_PI * m_params.filament_diameter * m_params.filament_diameter);
    double e_per_mm = mm3_per_mm * mm_filament_per_mm3;
    
    generateHeader(gcode_stream, num_layers);
    
    auto quadrants = getQuadrants();
    
    for (size_t quad_idx = 0; quad_idx < quadrants.size(); ++quad_idx) {
        bool is_last = (quad_idx == quadrants.size() - 1);
        generateQuadrantGCode(gcode_stream, quadrants[quad_idx], quad_idx, num_layers, e_per_mm, is_last);
    }
    
    generateFooter(gcode_stream);
    
    return gcode_stream.str();
}

} // namespace fullcontrol

